# 内存管理

## 虚拟内存

**作用：**

- 使得进程的运行内存超过物理内存大小，不经常使用的内存可以换出到物理内存之外。
- 每个进程的虚拟内存空间相互独立，解决了多进程之间地址冲突问题。
- 页表项除了物理地址外还有一些标记属性的比特，比如读写权限、存在位等。为访问内存提供更好的安全性。

## 申请空间

- 32位操作系统中，1G内核空间、3G用户空间，进程理论上最大能申请3G大小的虚拟内存。
- 64位操作系统中，内核空间与用户空间都为128T，其他部分为未定义的空间。即使物理内存只有4G，申请8G的虚拟内存也是可以的。如果这块虚拟内存被访问了，要看系统有没有swap分区：
  - 没有swap分区，因为物理空间不够，会触发OOM，导致进程被kill。
  - 有swap分区，即使物理内存只有4G，程序可以正常使用8G的内存。

## LRU优化

**预读失效**

- Linux OS: active list, inactive list
- MySql Innodb: young, old

**缓存污染**

- Linux OS: 在内存页被访问第二次时，才将页从 inactive list 移动至 active list
- MySQL Innodb: 在内存也被访问第二次时，对停留在old区域的时间判断：
  - 间隔小于1S（默认1S），则不会移动至young
  - 间隔大于1S，则从old移动至young

# 进程管理

## 进程通信方式

**管道**

- 匿名管道 | 
  - 通信范围局限于父子关系的进程。管道没有实体（管道文件），只能通过fork复制父进程fd文件描述符，来达到通信的目的。
- 命名管道 FIFO

**消息队列**

- 存在用户态与内核态之间的数据拷贝开销，因为数据在内核中传输

**共享内存**

- 进程拿出一块虚拟地址空间，映射到相同的物理内存中

**信号量**

- 整型计数器，主要用于实现进程间的互斥和同步，而不是缓存进程间通信的数据（P、V 操作）

**信号**

- 执行默认操作
- 捕捉
- 忽略
- SIGKILL和SIGSTOP不可捕捉或忽略

**socket**

- init
- bind
- listen
- accept
- connect
- wirte - read

## 死锁

**条件**

- 互斥
- 持有并等待
- 不可剥夺
- 环路

## 锁类型

- 互斥锁
  - 加锁失败后会释放CPU给其他线程，此时会发生线程上下文切换（仅线程私有资源）
- 自旋锁
  - 通过CPU提供的CAS (Compare And Swap) 函数实现
  - 加锁失败后会忙等待直到拿到锁
- 读写锁
  - 读优先、写优先、读写公平
- 悲观锁
  - 先加锁，再访问
- 乐观锁
  - 先修改，有冲突再重试
  - 实例：在线文档、git、svn

## 线程最大创建数

- 和虚拟地址空间（操作系统位数）有关
- ulimit -a可以查看创建一个线程所需要的stack size
- 和内核参数有关
  - /proc/sys/kernel/threads-max，系统支持的最大线程数，默认14553
  - /proc/sys/kernel/pid_max，PID号数值限制，默认32768
  - /proc/sys/vm/max_map_count，默认65530

# 调度算法

## 进程调度

**非抢占式**

- 先来先服务（First Comed First Services, FCFS）
  - 不利于短作业，适用于CPU繁忙型，不适用IO繁忙型
- 高响应比优先（Highest Response Ratio Next, HRRN）
  - 优先权 = （等待时间+要求服务时间）/ 要求服务时间
- 多级反馈队列

**抢占式**

- 最短作业优先（Shortest Job First, SJF）
- 时间片（Round Robin, RR）
  - 通常20ms~50ms
- 优先权（Highest Priority First, HPF）
  - 静态优先级/动态优先级
  - 非抢占式/抢占式

## 内存页面置换

**最佳页面**

- 理想算法，实际系统无法实现

**先进先出**

**最近最久未使用（LRU）**

**时钟（LOCK）**

**最不常用（LFU）**

## 磁道

**先来先服务（FCFS）**

**最短寻道时间优先（SSF）**

**扫描（SCAN）& 循环扫描（CSCAN）**

- 扫描到顶端
- SCAN反向移动途中会响应请求，CSCAN不会

**LOOK & CLOOK**

- 扫描到最远的请求
- LOOK反向移动途中会响应请求，CLOOK不会

# 文件管理

## 基本组成

**文件存储**

- 连续空间存放
- 非连续空间存放
  - 链表
  - 索引
- unix文件
  - 多级索引

**空闲空间管理**

- 空闲表
- 空闲链表
- 位图法

**文件I/O**

- 缓冲与非缓冲
- 直接与间接
- 阻塞与非阻塞
- 同步与异步
  - 阻塞、非阻塞、基于非阻塞的多路复用都属于同步
  - 异步IO（aio_read）

## 进程写文件时崩溃，数据是否会丢失？

进程执行write系统调用时，实际将数据写入到了内存的page cache内，数据一旦写入page cache，即使程序崩溃后续内核也会在合适的时机将数据写入到磁盘中。

但如果在page cache持久化到磁盘之前系统崩溃了，数据就没了。

**持久化方式**

- write back
- write through

# 设备管理

## 键盘输入时，操作系统发生了什么？

- 用户输入字符
- 键盘控制器产生扫描码数据并缓存至寄存器内，同时通过总线向CPU发起中断请求
- CPU保存当前进程的上下文，调用键盘的中断处理程序
- 从寄存器内读数据放至读缓冲队列
- 显示设备的驱动程序定时从【读缓冲队列】读取数据到【写缓冲队列】，再将【写缓冲队列】中的数据写入到显示设备的控制器的寄存器中的数据缓冲区用于屏幕显示

# 网络系统

