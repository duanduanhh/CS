# 基础

## 架构

### Server层

- 连接器
  - 长连接
    - 优点：可以减少断开连接和建立连接的过程，所以一般也推荐使用长连接
    - 缺点：占用内存可能会增多，因为MySQL执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。（1. 定期断开；2. 客户端主动重置连接）
- 解析器
  - 词法分析：识别关键字，构建SQL语法树
  - 语法分析
- 执行器
  - 预处理：判断表或字段是否存在
  - 优化：选择索引方案
  - 执行

### 存储引擎层

负责数据的存储和提取

- 从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎，支持索引类型是B+树



## 一行记录的存储结构

- Reduncant：已不再使用
- Compact：紧凑格式，5.1版本及之后的默认格式
  - 构成：
    - 记录的额外信息：
      - 变长字段长度列表（逆序存放）
      - NULL值列表（1bit占位，逆序存放）
      - 记录头信息：
        - delete_mask：表示此条数据是否被删除
        - next_record：下一条记录的位置
        - record_type：当前记录的类型
    - 记录的真实数据
      - 隐藏字段 (row_id, trx_id, roll_ptr)
      - 各列具体值
- Dynamic：基于 Compact 改进，5.7版本及之后的默认格式
- Compressed：基于 Compact 改进



**vachar(n) 中 n 最大值为多少**

除了TEXT、BLOBs这种大对象类型外，其他所有的列占用的字节长度加起来不能超过65535个字节。另外还要看数据库表的字符集，1个字符占用多少字节：ASCII一个字符一字节，UTF-8一个字符最多需要三个字节。

- 单字段时，n 最大值 = 65535 - 变长字段长度（2） - NULL值列表长度（1） = 65532
- 多字段时，保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535

**行溢出后，MySQL是怎么处理的**

- Compact：记录的真实数据处只会保存该列的一部分数据，以及20字节存储指向溢出页的地址
- Dynamic：记录的真实数据处只存储20个字节的指针来指向溢出页，所有数据都存储在溢出页



# 索引

## 分类

- 数据结构
  - B+
    - 主键索引和二级索引叶子节点的区别：主键索引叶子节点放的是实际数据，二级索引叶子结点放的是主键值，二级索引需要根据主键值回表查询实际数据
  - Hash
  - Full-text
- 物理存储
  - 主键（聚簇）：叶子结点存放的是实际数据
  - 二级（辅助）：叶子节点存放的是主键值，需要回表
- 字段特性
  - 主键
  - 唯一
  - 普通
  - 前缀
- 字段个数
  - 单列
  - 联合

## 特性

**B+树 vs B树**

- B+树只在叶子结点存储数据，单个节点的数据量更小，在相同的磁盘I/O次数下，就能查询到更多的节点。
- B+树叶子结点采用双链表连接，适合 MySQL 中常见的基于范围的顺序查找

**B+树 vs Hash**

- `hash` 适合查找，做等值查询，不适合做范围查询

**什么时候适用索引？**

- 字段有唯一性限制
- 经常用 `where` 查询条件的字段
- 经常用 `group by` 和 `order by` 的字段

**什么时候不需要创建索引？**

- `where, group by, order by` 用不到的字段，索引是为了定位
- 字段中有大量重复数据
- 表数据太少
- 经常更新的字段

**执行计划的常见参数**

- `possible_kyes` 字段表示可能用到的索引
- `key` 字段表示实际用的索引，常见索引（效率由低到高）
  - `ALL`，全表扫描
  - `index`，全索引扫描
  - `range`，索引范围扫描
  - `ref`，非唯一索引扫描
  - `eq_ref`，唯一索引扫描
  - `const`，结果只有一条的主键或唯一索引扫描
- `key_len` 表示索引的长度
- `rows` 表示扫描的数据行数
- `type` 表示数据扫描类型
- `extra` 
  - `using filesort` 
  - `using temporary` 对查询结果排序时使用临时表，效率低
  - `using index` 使用了覆盖索引

## 为什么使用B+树作为索引？

**演变：**

二分查找树 -> 平衡二叉树 -> B树 -> B+树



**原因：**

- B+树非叶子节点只存储索引信息，每次磁盘 I/O 可以读入更多的索引节点，查询效率更高
- B+树叶子结点存储所有数据项，增删节点可以通过操作叶子节点实现，非叶子节点并不存储数据，只是索引作用，作为冗余节点存在，因此增删操作效率更高
- B+树叶子节点用链表连接了起来，范围查询效率更高

## **索引优化**

- 前缀索引优化
- 覆盖索引优化
- 主键索引最好是自增的
  - 新增数据不需要移动已有的数据
- 非空
  - 索引最好设置为 `not null`， 否则会导致优化器做索引选择时更加复杂、更加难以优化
- 防止索引失效

## 索引失效

- 使用左或者左右模糊匹配
  - 因为底层按照索引值有序排列
- 查询条件中对索引列做了计算、函数、类型转换操作
  - 因为索引的是原始值，而不是计算后的值
  - 类型转换，字符串 -> 数字
    - `select "10" > 9 `可证明
- 联合索引要能正确使用需要遵循最左匹配原则
- where字句中，如果在 or 前的条件列是索引列，而在 or 后的条件列不是索引列
  - 只要有条件列不是索引列，索引就会失效



# 事务

## 基本特性

- 原子性
- 一致性：数据满足完整性约束
- 隔离性：防止多个事务并发执行时由于交叉执行而导致的数据不一致
- 持久性：保证数据永久修改

## 并行事务引发问题

- 脏读：读取到的数据还未提交
- 不可重复读：前后读取的数据不一致，针对同一条记录 update
- 幻读：前后读取了不同数量的数据，针对 insert, delete

## 事务的隔离级别

- 读未提交：会遇到脏读、不可重复读、幻读，一个事务未提交时所做的变更就可以被其他事务看到
- 读提交：会遇到不可重复读、幻读，一个事务提交后所做的变更才可以被其他事务看到，每个读语句创建 `Read View`
- 可重复度：会遇到幻读，一个事物执行中看到的数据和启动时看到的数据一致，启动事务时创建 `Read View`
- 串行化：对记录加上读写锁，如果发生了读写冲突，后访问的事务必须等前一个事务执行完成

## Read View

**组成：**

- `creator_trx_id` 创建该 Read View 事务的 id
- `m_ids` 创建该 Read View 时，当前数据库中活跃且未提交的事务 id 列表
- `min_trx_id` 创建该 Read View 时当前数据库中活跃且未提交的事务中的最小事务的事务 id
- `max_trx_id` 创建该 Read View 时当前数据库中应该给下一个事务的 id 值

**InnoDB 存储引擎的数据库表中，聚集索引包含两个隐藏列：**

- `trx_id` 当一个事物对某条聚簇索引记录进行改动时，就会把该事务的 id 记录在其中
- `roll_pointer` 每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 `undo` 日志中，这个隐藏列是个指针，指向每一个旧版本记录

## MySQL解决幻读方法

InnoDB引擎的默认隔离级别虽然是可重复读，不过很大程度上避免了幻读现象

- 快照读（普通 `select` 语句），MVCC方式（多版本并发控制）
- 当前读（`select ... for update`  等语句），next-key lock方式



# 锁

## 全局锁

操作范围为整个数据库，主要用于全库逻辑备份

```mysql
flush tables with read lock;
unlock tables;
# mysqldump 时加上 –single-transaction 可以在备份数据库前先开启事务，创建 Read View
```

## 表级锁

- 表锁

  ```mysql
  lock tables table read;
  lock tables table write;
  unlock tables;
  ```

- 元数据锁（MDL），事务提交后才会释放，执行期间一直持有

  - CURD 操作会自动加 MDL 读锁
  - 做表结构变更会自动加 MDL 写锁
  - 等待队列中写锁获取优先级高于读锁

- 意向锁

  - 意向共享
  - 意向独占

  ```mysql
  # 先在表上加上意向共享锁，然后对读取的记录加共享锁
  select ... lock in share mode;
  
  # 先表上加上意向独占锁，然后对读取的记录加独占锁
  select ... for update;
  ```

- AUTO-INC 锁

  - 主要用于 AUTO_INCREMENT 

## 行级锁

- Record Lock
- Gap Lock
  - 间隙锁之间兼容，不互斥

- Next-Key Lock
  - Record Lock + Gap Lock
- 插入意向锁
  - 特殊的间隙锁

## 如何加锁

### **唯一索引**

- 等值查询
  - 记录存在：next-key lock 退化为 record lock
  - 记录不存在：next-key lock 退化为 gap lock
- 范围查询
  - 大于等于
    - 等于查询值，next-key lock 退化为 record lock
    - 不等于查询值，next-key lock 退化为 gap lock
  - 大于
    - next-key lock 退化为 gap lock
  - 小于等于
    - 等于查询值，next-key lock 退化为 record lock
    - 不等于查询值，next-key lock 退化为 gap lock
  - 小于
    - next-key lock 退化为 gap lock

### 非唯一索引

- 等值查询
  - 满足查询条件：非唯一索引添加 next-key lock，对应的主键添加行 record lock
  - 不满足查询条件：先添加 next-key lock，退化为间隙锁
- 范围查询
  - 添加 next-key lock，不会发生退化，对应的主键添加行 record lock



# 日志

## undo log

Innodb 存储引擎日志，保证了事务的原子性，用于事务回滚和MVCC，记录了此次事务**完成后**的数据状态，记录的是更新之后的值

## redo log

Innodb 存储引擎日志，保证了事务的持久性，用于掉电等故障恢复，记录了此次事务**开始前**的数据状态，记录的是更新之前的值

**刷盘时机：**

- MySQL正常关闭时
- 当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发刷盘
- 后台线程每隔1S自动刷盘
- `innodb_flush_log_at_trx_commit` 参数可控制每次事务提交时直接刷盘
  - 0 — 不会主动触发写入磁盘的操作
  - 1 — 每次事务提交都自动刷盘
  - 2 — 每次事务提交时只缓存在 redo log buffer，刷盘操作由其他场景控制（每秒）

## binlog

server层归档日志，对任何存储引擎都可用，用于数据备份和主从复制，保存全量日志，追加写

**文件格式：**

- STATEMENT：存储SQL语句
- ROW：存储原始数据
- MIXED：自由选择

## 两阶段提交

1. Prepare 阶段
   1. 写入 redo log
2. Commit 阶段
   1. 写入 bin log
   2. 设置 bin log 为 commit 状态
   3. 设置 redo log 为 commit 状态

## 组提交

1. flush 阶段
2. sync 阶段
   1. 等待更多事务的 binlog 一起刷盘
3. commit 阶段

## MySQL 磁盘I/O 高，如何优化？

- 设置组提交的两个参数，延迟 binlog 刷盘时机，减少 binlog 的刷盘次数
  - `binlog_group_commit_sync_delay`
  - `binlog_group_commit_sync_no_delay_count`
- `sync_binlog` 设置为大于1的值，积累到指定的事务 binlog 才 fsync
- `innodb_flush_log_at_trx_commit` 设置为2，代表每次提交时只刷新到 redo log buffer，而非直接写入磁盘



# 内存

**链表分类：**

- Free List，管理空闲页
- Flush List，管理脏页
- LRU List，管理脏页+干净页

**LRU优化：**

- 新增 young 和 old 区域
- 新增 old区域停留时间 判断